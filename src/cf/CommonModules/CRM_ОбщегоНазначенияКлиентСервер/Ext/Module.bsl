
////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции

// Функция вычисляет контрастный цвет для фона.
//
// Параметры:
//	ЦветФона	- Цвет	- Цвет фона.
//
// Возвращаемое значение:
//	Цвет	- Контрастный цвет
//
Функция ПолучитьКонтрастныйЦвет(ЦветФона) Экспорт
    Яркость = 0.3 * ЦветФона.Красный + 0.59 * ЦветФона.Зеленый + 0.11 * ЦветФона.Синий;
    Возврат ?(Яркость  > 128, WebЦвета.Черный, WebЦвета.Белый);
КонецФункции // ПолучитьКонтрастныйЦвет()

// Функция возвращает представление информации об ошибке.
//
// Параметры:
//	ИнформацияОбОшибке		- Строка	- Информация об ошибке.
//	КраткоеПредставление	- Булево	- Флаг краткого представления.
//
// Возвращаемое значение:
//	Строка - Представление информации об ошибке.
//
Функция ПолучитьПредставленияИнформацииОбОшибке(ИнформацияОбОшибке, КраткоеПредставление = Истина) Экспорт
	Если КраткоеПредставление Тогда
		Возврат КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
	Иначе
		Возврат ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецЕсли;
КонецФункции // ПолучитьПредставленияИнформацииОбОшибке()

// Процедура переносит ДеревоЗначений в реквизит формы.
//
// Параметры:
//	СтрокиИсточник		- КоллекцияСтрокДереваЗначений	- Строки дерева значений.
//	ЭлементыПриемник	- ЭлементУправления				- Реквизит формы.
//
Процедура СкопироватьДеревоВРеквизитФормы(СтрокиИсточник, ЭлементыПриемник) Экспорт
	Для Каждого СтрокаИсточник Из СтрокиИсточник Цикл
		НоваяСтрока = ЭлементыПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИсточник);
		Если СтрокаИсточник.Строки.Количество() > 0 Тогда
			СкопироватьДеревоВРеквизитФормы(СтрокаИсточник.Строки, НоваяСтрока.ПолучитьЭлементы());
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры // СкопироватьДеревоВРеквизитФормы()

// Функция ищет строки в реквизите формы типа "ДеревоЗначений".
//
// Параметры:
//	ЭлементыСтрокДерева		- КоллекцияСтрокДереваЗначений	- Строки дерева значений.
//	СтруктураПоиска			- Структура						- Структура поиска.
//	Рекурсивно				- Булево						- Флаг рекурсии.
//	МассивНайденныхСтрок	- Массив						- Массив найденных строк.
//
// Возвращаемое значение:
//	Массив	- Массив найденных строк.
//
Функция НайтиВЭлементахДерева(ЭлементыСтрокДерева, СтруктураПоиска, Рекурсивно = Ложь, МассивНайденныхСтрок = Неопределено) Экспорт
	Если МассивНайденныхСтрок = Неопределено Тогда
		Массив = Новый Массив();
	Иначе
		Массив = МассивНайденныхСтрок;
	КонецЕсли;
	Для Каждого СтрокаДерева Из ЭлементыСтрокДерева Цикл
		бНайдено = Истина;
		Для Каждого СтруктураПоискаКлючЗначение Из СтруктураПоиска Цикл
			Если СтрокаДерева[СтруктураПоискаКлючЗначение.Ключ] <> СтруктураПоискаКлючЗначение.Значение Тогда
				бНайдено = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если бНайдено Тогда
			Массив.Добавить(СтрокаДерева);
		КонецЕсли;
		Если Рекурсивно Тогда
			ПодчиненныеСтроки = СтрокаДерева.ПолучитьЭлементы();
			Если ПодчиненныеСтроки.Количество() > 0 Тогда
				НайтиВЭлементахДерева(ПодчиненныеСтроки, СтруктураПоиска, Рекурсивно, Массив);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Массив;
КонецФункции // НайтиВЭлементахДерева()

// Функция форматирования сумм.
//
// Параметры: 
//	Сумма	- Число				- Число, которое мы хотим форматировать.
//  Валюта	- СправочникСсылка	- Ссылка на элемент справочника валют, если задан, то к в
//				                результирующую строку будет добавлено представление валюты.
//  ЧН		- Строка			- Строка, представляющая нулевое значение числа.
//  ЧРГ		- Строка			- Символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//	Строка	- Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт
	ФорматнаяСтрока = "ЧЦ=15; ЧДЦ=2" + ?(НЕ ЗначениеЗаполнено(ЧН), "; ЧН=0", "; ЧН=" + ЧН) 
		+ ?(НЕ ЗначениеЗаполнено(ЧРГ), "", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	Если ЗначениеЗаполнено(Валюта) Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;
	Возврат РезультирующаяСтрока;
КонецФункции // ФорматСумм()

// Процедура копирует отбор компоновки данных.
//
// Параметры:
//	ЭлементыПриемник	- ЭлементУправления	- Реквизит формы.
//	ЭлементыИсточник	- ЭлементУправления	- Реквизит формы.
//	ДоступныеПоляОтбора	- Структура			- Доступные поля отбора.
//
Процедура СкопироватьОтборКомпоновкиДанных(ЭлементыПриемник, ЭлементыИсточник, ДоступныеПоляОтбора = Неопределено) Экспорт
	Для Каждого ЭлементОтбора Из ЭлементыИсточник Цикл
		Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			НовыйЭлементОтбора = ЭлементыПриемник.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			ЗаполнитьЗначенияСвойств(НовыйЭлементОтбора, ЭлементОтбора);
			СкопироватьОтборКомпоновкиДанных(НовыйЭлементОтбора.Элементы, ЭлементОтбора.Элементы);
		Иначе
			Если ДоступныеПоляОтбора <> Неопределено Тогда
				Если ДоступныеПоляОтбора.НайтиПоле(Новый ПолеКомпоновкиДанных(Строка(ЭлементОтбора.ЛевоеЗначение))) = Неопределено Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			НовыйЭлементОтбора = ЭлементыПриемник.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЗаполнитьЗначенияСвойств(НовыйЭлементОтбора, ЭлементОтбора);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры // СкопироватьОтборКомпоновкиДанных()

// ++ Харченко Д.И. №  - 14.09.2018 / 
Процедура СкопироватьПараметрыКомпоновки(ЭлементыПриемник, ЭлементыИсточник) Экспорт
	Для Каждого ЭлементПараметр Из ЭлементыИсточник.Элементы Цикл
		
		Поиск = ЭлементыПриемник.НайтиЗначениеПараметра(ЭлементПараметр.Параметр);
		
		Если НЕ Поиск = Неопределено Тогда
			Поиск.Значение = ЭлементПараметр.Значение;	
		КонецЕсли;
		
	КонецЦикла;
КонецПроцедуры // СкопироватьПараметрыКомпоновки()
// -- Харченко Д.И. №  - 14.09.2018

// Функция возвращает период, увеличенный на количество периодов.
//
// Параметры:
//	БазоваяДата			- Дата					- Дата, относительно которой рассчитывается период.
//	Периодичность 		- ПеречислениеСсылка	- Размер периода.
//	КоличествоПериодов	- Число					- Количество периодов, на которое нужно расширить базовый.
//												Если = 0, то возвращается период, в котором находится базовая дата,
//												если < 0, то возвращаются период, соответствующий предыдущим периодам,
//												если > 0, то возвращаются период, соответствующий следующим периодам.
//
// Возвращаемое значение:
//	СтандартныйПериод	- Увеличенный период.
//
Функция РасширенныйПериод(БазоваяДата, Периодичность, КоличествоПериодов = 0) Экспорт
	ОдинДень = 86400;
	Период = Новый СтандартныйПериод;
	Период.Вариант = ВариантСтандартногоПериода.ПроизвольныйПериод;
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда
		Период.ДатаНачала    = НачалоДня(БазоваяДата);
		Период.ДатаОкончания = КонецДня(БазоваяДата);
		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = Период.ДатаНачала + ОдинДень * КоличествоПериодов;
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = Период.ДатаОкончания + ОдинДень * КоличествоПериодов;
		КонецЕсли;
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		Период.ДатаНачала    = НачалоНедели(БазоваяДата);
		Период.ДатаОкончания = КонецНедели(БазоваяДата);
		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = Период.ДатаНачала + ОдинДень * 7 * КоличествоПериодов;
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = Период.ДатаОкончания + ОдинДень * 7 * КоличествоПериодов;
		КонецЕсли;
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда
		ДеньМесяца = День(БазоваяДата);
		Если ДеньМесяца <= 10 Тогда
			НомерДекады = 1;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НомерДекады = 2;
		Иначе
			НомерДекады = 3;
		КонецЕсли;
		НомерДекады = НомерДекады + КоличествоПериодов;
		Если НомерДекады > 0 Тогда
			СмещениеМесяцев = Цел((НомерДекады-1)/3);
		Иначе
			СмещениеМесяцев = -1 - Цел((-НомерДекады)/3);
		КонецЕсли;
		НомерДекады = НомерДекады - 3*СмещениеМесяцев;
		СмещеннаяДата = ДобавитьМесяц(НачалоМесяца(БазоваяДата), СмещениеМесяцев) + (НомерДекады-1) * 10 * ОдинДень;
		ДеньМесяца = День(СмещеннаяДата);
		Если ДеньМесяца <= 10 Тогда
			Период.ДатаНачала    = НачалоМесяца(СмещеннаяДата);
			Период.ДатаОкончания = Период.ДатаНачала + ОдинДень * 9;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			Период.ДатаНачала    = НачалоМесяца(СмещеннаяДата) + ОдинДень * 9;
			Период.ДатаОкончания = НачалоМесяца(СмещеннаяДата) + ОдинДень * 19;
		Иначе
			Период.ДатаНачала    = НачалоМесяца(СмещеннаяДата) + ОдинДень * 19;
			Период.ДатаОкончания = КонецМесяца(СмещеннаяДата);
		КонецЕсли;
	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда
		Период.ДатаНачала    = НачалоМесяца(БазоваяДата);
		Период.ДатаОкончания = КонецМесяца(БазоваяДата);
		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала = ДобавитьМесяц(Период.ДатаНачала, КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, КоличествоПериодов);
		КонецЕсли;
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда
		Период.ДатаНачала    = НачалоКвартала(БазоваяДата);
		Период.ДатаОкончания = КонецКвартала(БазоваяДата);
		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = ДобавитьМесяц(Период.ДатаНачала, 3*КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, 3*КоличествоПериодов);
		КонецЕсли;
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда
		Если Месяц(БазоваяДата) < 7 Тогда
			Период.ДатаНачала    = НачалоГода(БазоваяДата);
			Период.ДатаОкончания = КонецГода(ДобавитьМесяц(Период.ДатаНачала, - 6));
		Иначе
			Период.ДатаНачала    = ДобавитьМесяц(НачалоГода(БазоваяДата), 6);
			Период.ДатаОкончания = КонецГода(БазоваяДата);
		КонецЕсли;
		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = ДобавитьМесяц(Период.ДатаНачала, 6*КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, 6*КоличествоПериодов);
		КонецЕсли;
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда
		Период.ДатаНачала    = НачалоГода(БазоваяДата);
		Период.ДатаОкончания = КонецГода(БазоваяДата);
		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = ДобавитьМесяц(Период.ДатаНачала, 12*КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, 12*КоличествоПериодов);
		КонецЕсли;
	КонецЕсли;
	Возврат Период;
КонецФункции

// Функция рассчитывает дату окончания периода.
//
// Параметры:
//	ДатаНачала          - Дата					- Дата начала, от которой будет рассчитана дата окончания периода.
//	Периодичность		- ПеречислениеСсылка	- Значение перечисления "Периодичность".
//	КоличествоПериодов	- Число					- Количество повторов периода.
//
// Возвращаемое значение:
//	Дата	- Дата окончания периода.
//
Функция РассчитатьДатуОкончанияПериода(ДатаНачала, Периодичность, КоличествоПериодов) Экспорт
	ОдинДень = 86400;
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда 
		ДатаОкончания = ДатаНачала + ОдинДень * КоличествоПериодов;
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		ДатаОкончания = ДатаНачала + ОдинДень * 7 * КоличествоПериодов;
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда
		ДеньМесяца = День(ДатаНачала);
		НачМесяца = НачалоМесяца(ДатаНачала);
		Если ДеньМесяца <= 10 Тогда
			НомерДекады = 1;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НомерДекады = 2;
		Иначе
			НомерДекады = 3;
		КонецЕсли;
		НомерДекады = НомерДекады + КоличествоПериодов;
		Если НомерДекады > 0 Тогда
			Месяцев = Цел((НомерДекады-1)/3);
		Иначе
			Месяцев = -1 - Цел((-НомерДекады)/3);
		КонецЕсли;
		НомерДекады = НомерДекады - 3*Месяцев;
		Дт = ДобавитьМесяц(НачМесяца, Месяцев) + (НомерДекады-1) * 10 * ОдинДень;
		Если КоличествоПериодов > 0 Тогда
			ДатаОкончания = Дт;
		Иначе 
			ДеньМесяца = День(Дт);
			Если ДеньМесяца <= 10 Тогда
				ДатаОкончания = КонецДня(НачалоМесяца(Дт) + ОдинДень * 9);
			ИначеЕсли ДеньМесяца <= 20 Тогда
				ДатаОкончания = КонецДня(НачалоМесяца(Дт) + ОдинДень * 19);
			Иначе
				ДатаОкончания = КонецМесяца(Дт);
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, КоличествоПериодов);
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 3 * КоличествоПериодов);
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 6 * КоличествоПериодов);
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 12 * КоличествоПериодов);
	КонецЕсли;
	Возврат КонецДня(ДатаОкончания-ОдинДень);
КонецФункции // РассчитатьДатуОкончанияПериода()

// Функция рассчитывает ближайшую к указанной дату начала периода.
//
// Параметры:
//	ДатаНачала		- Дата					- Дата, к которой будет рассчитана ближайшая дата начала периода.
//	Периодичность	- ПеречислениеСсылка	- Значение перечисления "Периодичность".
//
// Возвращаемое значение:
//	Дата	- Дата начала ближайшего периода.
//
Функция РассчитатьДатуНачалаБлижайшегоПериода(ДатаНачала, Периодичность) Экспорт
	ОдинДень = 86400;
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда
		БлижайшаяДата = ДатаНачала;
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		Если ДатаНачала = НачалоНедели(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецНедели(ДатаНачала) + ОдинДень;
		КонецЕсли;
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда
		ДеньМесяца   = День(ДатаНачала);
		НачалоМесяца = НачалоМесяца(ДатаНачала);
		Если ДеньМесяца = 1 Или ДеньМесяца = 11 Или ДеньМесяца = 21 Тогда
			БлижайшаяДата = ДатаНачала;
		ИначеЕсли ДеньМесяца <= 10 Тогда // Первая декада
			БлижайшаяДата = НачалоМесяца + ОдинДень * 10;
		ИначеЕсли ДеньМесяца <= 20 Тогда // Вторая декада
			БлижайшаяДата = НачалоМесяца + ОдинДень * 20;
		Иначе // Третья декада
			БлижайшаяДата = КонецМесяца(НачалоМесяца) + ОдинДень;
		КонецЕсли;
	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда
		Если ДатаНачала = НачалоМесяца(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецМесяца(ДатаНачала) + ОдинДень;
		КонецЕсли;
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда
		Если ДатаНачала = НачалоКвартала(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецКвартала(ДатаНачала) + ОдинДень;
		КонецЕсли;
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда
		НачалоГода      = НачалоГода(ДатаНачала);
		НачалоПолугодия = ДобавитьМесяц(НачалоГода,6);
		Если ДатаНачала = НачалоПолугодия Или ДатаНачала = НачалоГода Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = ?(ДатаНачала > НачалоПолугодия, КонецГода(ДатаНачала) + ОдинДень, НачалоПолугодия);
		КонецЕсли;
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда
		Если ДатаНачала = НачалоГода(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецГода(ДатаНачала) + ОдинДень;
		КонецЕсли;
	КонецЕсли;
	Возврат БлижайшаяДата;
КонецФункции // РассчитатьДатуНачалаБлижайшегоПериода()

// Процедура проверяет Табличную часть документа на существование в ней строк-полных дублей.
//
// Параметры:
//  ТЧ 				-  Табличная часть - Табличная часть, в которой будет осуществляться проверка на дубли.
//
Процедура ПроверкаНаДублиВТЧ(ТЧ) Экспорт
	
	ТаблЗнач = ТЧ.Выгрузить();
	Пометка = Ложь;
	
	Отбор = Новый Структура();
	
	Для каждого Стр Из ТаблЗнач Цикл
		НомераСтрок = "";
		Отбор.Очистить();
		Для каждого Колонки Из ТаблЗнач.Колонки Цикл
			Если Колонки.Имя <> "НомерСтроки" Тогда
				Отбор.Вставить(Колонки.Имя, Стр[Колонки.Имя]);
			КонецЕсли;
		КонецЦикла;
		
		Строки = ТаблЗнач.НайтиСтроки(Отбор);
		Если Строки.Количество() > 1 Тогда
			Пометка = Истина;
			ТабЗн = ТЧ.Выгрузить();
			Для каждого НайденныеСтроки Из Строки Цикл
				Если НомераСтрок <> "" Тогда
					НомераСтрок = НомераСтрок + ", " + НайденныеСтроки.НомерСтроки;
				Иначе
					НомераСтрок = НомераСтрок + НайденныеСтроки.НомерСтроки;
				КонецЕсли;
			КонецЦикла;
			МассивДублирующихСтрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(НомераСтрок);
			
			Для каждого Стр Из МассивДублирующихСтрок Цикл
				Индекс = МассивДублирующихСтрок.Найти(Стр);
				Если Индекс <> 0 Тогда
					Параметр = Число(Стр);
					НайденнаяСтрока = ТабЗн.Найти(Параметр, "НомерСтроки");
					ТабЗн.Удалить(НайденнаяСтрока);
				КонецЕсли;
			КонецЦикла;
			ТЧ.Загрузить(ТабЗн);
			ТаблЗнач = ТЧ.Выгрузить();                                      
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьВремяВСекундах(Дата) Экспорт
	Возврат Час(Дата)*3600+Минута(Дата)*60+Секунда(Дата);
КонецФункции

// Функция преобразовывает поступаемую на вход строку (например, "05.06.2010") в дату.
//
// Параметры:
//  СтрокаДаты - Строка - Строка для преобразования.
//
// Возвращаемое значение:
//  Дата1С - Дата - Преобразованная строка.
//
Функция СтрокаДатыВДату1С(СтрокаДаты) Экспорт
	Попытка 
		Возврат Дата(Сред(СтрокаДаты,7,4)+Сред(СтрокаДаты,4,2)+Лев(СтрокаДаты,2)) 
	Исключение 
		Возврат Дата('00010101'); 
	КонецПопытки; 
КонецФункции	

////////////////////////////////////////////////////////////////////////////////
// Блок процедур и функций для работы с пользовательскими настройками динамических списков.

// Процедура обрабатывает команду выбора настройки пользовательского списка из меню.
//
// Параметры:
//  ЭтаФорма						- УправляемаяФорма	- Форма списка.
//  СвойстваДинамическогоСписка 	- Структура			- Структура содержащая свойства динамического списка.
//  ПризнакИзмененыНастройки		- Булево			- Признак того, что были изменены настройки.
//
Процедура ОбработкаКомандыПользовательскихНастроекДинамическогоСписка(ЭтаФорма, СвойстваДинамическогоСписка, ПризнакИзмененыНастройки = Неопределено) Экспорт
	Если ПризнакИзмененыНастройки = Истина Тогда
		CRM_ОбщегоНазначенияСервер.ПользовательскиеНастройкиСпискаЗаполнитьПодменюНастроек(ЭтаФорма, СвойстваДинамическогоСписка);
	КонецЕсли;
	
	Если ПризнакИзмененыНастройки = Неопределено Или  (ПризнакИзмененыНастройки = Истина И ЭтаФорма[СвойстваДинамическогоСписка.ИмяПеременнойТекущейНастройки] <> "") Тогда
		CRM_ОбщегоНазначенияКлиентСервер.ПрименитьПользовательскиеНастройкиКДинамическомуСписку(
			ЭтаФорма[СвойстваДинамическогоСписка.ИмяСписка], ЭтаФорма[СвойстваДинамическогоСписка.ИмяПеременнойТекущейНастройки], СвойстваДинамическогоСписка.ИдентификаторСписка);
		//
	КонецЕсли;
	
	Если НЕ CRM_ОбщегоНазначенияСервер.ПользовательскиеНастройкиСпискаУстановитьНастройкуПоУмолчанию(СвойстваДинамическогоСписка.ИдентификаторСписка, ЭтаФорма[СвойстваДинамическогоСписка.ИмяПеременнойТекущейНастройки]) Тогда
		// Настройка не найдена
		ЭтаФорма[СвойстваДинамическогоСписка.ИмяПеременнойТекущейНастройки] = "";
	КонецЕсли;
КонецПроцедуры

// Процедура применяет пользовательские настройки к динамическому списку.
//
// Параметры:
//  ДинамическийСписок			- ДинамическийСписок	- Динамический список к которому нужно применить настройки;
//  Настройки           		- Структура или Строка	- Применяемые настройки; в случае если передается строка - параметр
//                          считается идентификатором сохраненных настроек и функция получит структуру
//                                      		        с настройками из хранилища настроек форм;
//  ИдентификаторСписка			- Строка				- Идентификатор списка, имеет смысл только в случае если параметр Настройки -
//                                      строка.
//	ОчищатьОтбор				- Булево				- Флаг очистки отбора.
//	ОчищатьГруппировки			- Булево				- Флаг очистки группировок.
//	ОчищатьУсловноеОформление	- Булево				- Флаг очистки условного оформления.
//
Процедура ПрименитьПользовательскиеНастройкиКДинамическомуСписку(ДинамическийСписок, Настройки,
		ИдентификаторСписка = Неопределено, Знач ОчищатьОтбор = Истина, Знач ОчищатьГруппировки = Истина,
		Знач ОчищатьУсловноеОформление = Истина) Экспорт
	
	Если ТипЗнч(Настройки) = Тип("Строка") Тогда
		Если ИдентификаторСписка = Неопределено Тогда
			Возврат;
		КонецЕсли;
		СтруктураНастройки = CRM_ОбщегоНазначенияСервер.ВосстановитьПользовательскиеНастройкиДинамическогоСписка(ИдентификаторСписка, Настройки);
	Иначе
		СтруктураНастройки = Настройки;
	КонецЕсли;
	
	Если ОчищатьОтбор Тогда
		ДинамическийСписок.Отбор.Элементы.Очистить();
	КонецЕсли;
	Если ОчищатьГруппировки Тогда
		ДинамическийСписок.Группировка.Элементы.Очистить();
	КонецЕсли;
	Если ОчищатьУсловноеОформление Тогда
		ДинамическийСписок.УсловноеОформление.Элементы.Очистить();
	КонецЕсли;
	Если ТипЗнч(СтруктураНастройки) <> Тип("Структура") Тогда Возврат; КонецЕсли;
	Если СтруктураНастройки.Свойство("Отбор") И ТипЗнч(СтруктураНастройки.Отбор) = Тип("ОтборКомпоновкиДанных") Тогда
		Если НЕ ОчищатьОтбор Тогда
			ДинамическийСписок.Отбор.Элементы.Очистить();
		КонецЕсли;
		СкопироватьОтборКомпоновкиДанных(ДинамическийСписок.Отбор.Элементы, СтруктураНастройки.Отбор.Элементы, ДинамическийСписок.Отбор.ДоступныеПоляОтбора);
	КонецЕсли;
	Если СтруктураНастройки.Свойство("Группировка") И ТипЗнч(СтруктураНастройки.Группировка) = Тип("ПоляГруппировкиКомпоновкиДанных") Тогда
		Если НЕ ОчищатьГруппировки Тогда
			ДинамическийСписок.Группировка.Элементы.Очистить();
		КонецЕсли;
		СкопироватьГруппировкуКомпоновкиДанных(ДинамическийСписок.Группировка.Элементы, СтруктураНастройки.Группировка.Элементы);
	КонецЕсли;
	Если СтруктураНастройки.Свойство("УсловноеОформление") И ТипЗнч(СтруктураНастройки.УсловноеОформление) = Тип("УсловноеОформлениеКомпоновкиДанных") Тогда
		Если НЕ ОчищатьУсловноеОформление Тогда
			ДинамическийСписок.УсловноеОформление.Элементы.Очистить();
		КонецЕсли;
		СкопироватьУсловноеОформлениеКомпоновкиДанных(ДинамическийСписок.УсловноеОформление.Элементы, СтруктураНастройки.УсловноеОформление.Элементы)
	КонецЕсли;
КонецПроцедуры // ПрименитьПользовательскиеНастройкиКДинамическомуСписку()

// Процедура копирует группировку компоновки данных.
//
// Параметры:
//	ЭлементыПриемник	- ЭлементУправления	- Реквизит формы.
//	ЭлементыИсточник	- ЭлементУправления	- Реквизит формы.
//
Процедура СкопироватьГруппировкуКомпоновкиДанных(ЭлементыПриемник, ЭлементыИсточник) Экспорт
	Для Каждого ЭлементГруппировки Из ЭлементыИсточник Цикл
		НовыйЭлемент = ЭлементыПриемник.Добавить(ТипЗнч(ЭлементГруппировки));
		ЗаполнитьЗначенияСвойств(НовыйЭлемент, ЭлементГруппировки);
	КонецЦикла;
КонецПроцедуры // СкопироватьГруппировкуКомпоновкиДанных()

// Процедура копирует условное оформление компоновки данных.
//
// Параметры:
//	ЭлементыПриемник	- ЭлементУправления	- Реквизит формы.
//	ЭлементыИсточник	- ЭлементУправления	- Реквизит формы.
//
Процедура СкопироватьУсловноеОформлениеКомпоновкиДанных(ЭлементыПриемник, ЭлементыИсточник) Экспорт
	Для Каждого ЭлементУсловногоОформления Из ЭлементыИсточник Цикл
		НовыйЭлемент = ЭлементыПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(НовыйЭлемент, ЭлементУсловногоОформления);
		СкопироватьОтборКомпоновкиДанных(НовыйЭлемент.Отбор.Элементы, ЭлементУсловногоОформления.Отбор.Элементы);
		СкопироватьОформлениеКомпоновкиДанных(НовыйЭлемент.Оформление, ЭлементУсловногоОформления.Оформление);
		СкопироватьПоляОформленияКомпоновкиДанных(НовыйЭлемент.Поля, ЭлементУсловногоОформления.Поля);
	КонецЦикла;
КонецПроцедуры // СкопироватьУсловноеОформлениеКомпоновкиДанных()

// Процедура, используется процедурой "СкопироватьУсловноеОформлениеКомпоновкиДанных".
//
// Параметры:
//	ОформлениеПриемник	- ЭлементУсловногоОформления	- Приемник
//	ОформлениеИсточник	- ЭлементУсловногоОформления	- Источник
//
Процедура СкопироватьОформлениеКомпоновкиДанных(ОформлениеПриемник, ОформлениеИсточник) Экспорт
	Для Каждого ЭлементОформления Из ОформлениеИсточник.Элементы Цикл
		ЗначениеПараметра = ОформлениеПриемник.НайтиЗначениеПараметра(ЭлементОформления.Параметр);
		Если ЗначениеПараметра <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(ЗначениеПараметра, ЭлементОформления);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры // СкопироватьОформлениеКомпоновкиДанных()

// Процедура, используется процедурой "СкопироватьУсловноеОформлениеКомпоновкиДанных".
//
// Параметры:
//	ОформлениеПриемник	- ОформляемоеПолеКомпоновкиДанных	- Приемник
//	ОформлениеИсточник	- ОформляемоеПолеКомпоновкиДанных	- Источник
//
Процедура СкопироватьПоляОформленияКомпоновкиДанных(ПоляПриемник, ПоляИсточник) Экспорт
	Для Каждого ЭлементПоле Из ПоляИсточник.Элементы Цикл
		НовоеПоле = ПоляПриемник.Элементы.Добавить();
		ЗаполнитьЗначенияСвойств(НовоеПоле, ЭлементПоле);
	КонецЦикла;
КонецПроцедуры // СкопироватьПоляОформленияКомпоновкиДанных()

////////////////////////////////////////////////////////////////////////////////
// Блок процедур и функций для работы с быстрыми отборами динамических списков.

// Функция определяет имя поля списка по элементу быстрого отбора.
//
// Параметры:
//	Элемент	- ЭлементУправления	- Элемент быстрого отбора.
//
// Возвращаемое значение:
//	Неопределено или Строка	- Имя поля списка.
//
Функция БыстрыйОтборОпределитьИмяПоляПоЭлементу(Элемент) Экспорт
	Попытка
		ИмяЭлемента = Элемент.Имя;
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СпецСтрока = "ПолеБыстрогоОтбора_";
	ПозицияСпецСтроки = Найти(ИмяЭлемента, СпецСтрока);
	Если ПозицияСпецСтроки <= 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Возврат СокрЛП(Сред(ИмяЭлемента, ПозицияСпецСтроки + СтрДлина(СпецСтрока)));
КонецФункции // БыстрыйОтборОпределитьИмяПоляПоЭлементу()

// Процедура применяет значение поля быстрого отбора к отбору списка.
//
// Параметры:
//	Список						- СписокЗначений	- Список
//	Элемент						- ЭлементУправления	- Элемент быстрого отбора.
//	ЭтаФорма					- УправляемаяФорма	- Форма
//	ИмяПоля						- Строка			- Имя поля.
//	Значение					- Произвольный		- Значение отбора.
//	Использование				- Булево			- Флаг использования отбора.
//	ИгнорироватьПустоеЗначение	- Булево			- Флаг использования пустого значения отбора.
//
Процедура БыстрыйОтборПрименитьОтборКСписку(Список, Элемент = Неопределено, ЭтаФорма = Неопределено,
		ИмяПоля = Неопределено, Знач Значение = Неопределено, Использование = Неопределено, ИгнорироватьПустоеЗначение = Ложь) Экспорт
	Если ИмяПоля = Неопределено Тогда
		ИмяПоля = БыстрыйОтборОпределитьИмяПоляПоЭлементу(Элемент);
	КонецЕсли;
	Если ИмяПоля = Неопределено Тогда Возврат; КонецЕсли;
	Если Значение = Неопределено Тогда
		Если ЭтаФорма = Неопределено Или Элемент = Неопределено Тогда Возврат; КонецЕсли;
		Попытка
			Значение = ЭтаФорма[Элемент.Имя];
		Исключение
			Возврат;
		КонецПопытки;
	КонецЕсли;
	Если ИгнорироватьПустоеЗначение И НЕ ЗначениеЗаполнено(Значение) Тогда
		Возврат;
	КонецЕсли;
	Отбор = Список.Отбор;
	Если Использование = Неопределено Тогда
		Использование = ЗначениеЗаполнено(Значение);
	КонецЕсли;
	ОбщегоНазначенияКлиентСервер.УдалитьЭлементыГруппыОтбора(Отбор, ИмяПоля);
	Если Использование Тогда
		ЭлементОтбора = Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
		ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		ЭлементОтбора.ПравоеЗначение = Значение;
		ЭлементОтбора.Использование = Истина;
	КонецЕсли;
КонецПроцедуры // БыстрыйОтборПрименитьОтборКСписку()

// Процедура применяет значения полей быстрых отборов для элемента-группы полей быстрых отборов.
//
// Параметры:
//	Список						- СписокЗначений	- Список
//	ЭлементГруппа				- ЭлементУправления	- Элемент быстрого отбора.
//	ЭтаФорма					- УправляемаяФорма	- Форма
//	Использование				- Булево			- Флаг использования отбора.
//	ИгнорироватьПустыеЗначения	- Булево			- Флаг использования пустого значения отбора.
//
Процедура БыстрыйОтборПрименитьГруппуОтборовКСписку(Список, ЭлементГруппа, ЭтаФорма, Использование = Неопределено, ИгнорироватьПустыеЗначения = Ложь) Экспорт
	ПодчиненныеЭлементы = ЭлементГруппа.ПодчиненныеЭлементы;
	Для Каждого Элемент Из ПодчиненныеЭлементы Цикл
		ИмяПоля = БыстрыйОтборОпределитьИмяПоляПоЭлементу(Элемент);
		Если ИмяПоля = Неопределено Тогда Продолжить; КонецЕсли;
		БыстрыйОтборПрименитьОтборКСписку(Список, Элемент, ЭтаФорма, ИмяПоля,, Использование, ИгнорироватьПустыеЗначения);
	КонецЦикла;
КонецПроцедуры // БыстрыйОтборПрименитьГруппуОтборовКСписку()

////////////////////////////////////////////////////////////////////////////////
// Блок процедур функций для работы с событиями.

// Функция возвращает картинку вида события.
//
// Параметры:
//	ВидСобытия			- ПеречислениеСсылка	- Вид события.
//	ВходящееИсходящее	- ПеречислениеСсылка	- Признак события.
//
// Возвращаемое значение:
//	Картинка	- Картинка вида события.
//
Функция ПолучитьКартинкуВидаСобытия(ВидСобытия, ВходящееИсходящее = Неопределено) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ВидСобытия) Тогда
		Возврат Новый Картинка();
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ВходящееИсходящее) Тогда
		Входящее = (ВходящееИсходящее = ПредопределенноеЗначение("Перечисление.CRM_ВходящееИсходящееСобытие.Входящее"));
	Иначе
		Входящее = Неопределено;
	КонецЕсли;
	
	Если Входящее = Неопределено Тогда
		
		Если ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.ТелефонныйЗвонок") Тогда
		
			Возврат БиблиотекаКартинок.CRM_ТелефонныйЗвонок;
			
		ИначеЕсли ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.ЛичнаяВстреча") Тогда
			
			Возврат БиблиотекаКартинок.CRM_ЛичнаяВстреча;
			
		ИначеЕсли ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.Прочее") Тогда
			
			Возврат БиблиотекаКартинок.CRM_ПрочееСобытие;
			
		ИначеЕсли ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.ПочтовоеПисьмо") Тогда
			
			Возврат БиблиотекаКартинок.CRM_ПочтовоеПисьмо;
			
		ИначеЕсли ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.ЭлектронноеПисьмо") Тогда
			
			Возврат БиблиотекаКартинок.CRM_ЭлектронноеПисьмо;
			
		Иначе
			
			Возврат БиблиотекаКартинок.CRM_ПрочееСобытие;
			
		КонецЕсли;
		
	ИначеЕсли Входящее Тогда
		Если ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.ТелефонныйЗвонок") Тогда
		
			Возврат БиблиотекаКартинок.CRM_ТелефонныйЗвонокВходящий;
			
		ИначеЕсли ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.ЛичнаяВстреча") Тогда
			
			Возврат БиблиотекаКартинок.CRM_ЛичнаяВстречаВходящая;
			
		ИначеЕсли ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.Прочее") Тогда
			
			Возврат БиблиотекаКартинок.CRM_ПрочееСобытиеВходящее;
			
		ИначеЕсли ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.ПочтовоеПисьмо") Тогда
			
			Возврат БиблиотекаКартинок.CRM_ПочтовоеПисьмоВходящее;
			
		ИначеЕсли ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.ЭлектронноеПисьмо") Тогда
			
			Возврат БиблиотекаКартинок.CRM_ЭлектронноеПисьмоВходящее;
			
		Иначе
			
			Возврат БиблиотекаКартинок.CRM_ПрочееСобытиеВходящее;
			
		КонецЕсли;
		
	Иначе
		Если ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.ТелефонныйЗвонок") Тогда
		
			Возврат БиблиотекаКартинок.CRM_ТелефонныйЗвонокИсходящий;
			
		ИначеЕсли ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.ЛичнаяВстреча") Тогда
			
			Возврат БиблиотекаКартинок.CRM_ЛичнаяВстречаИсходящая;
			
		ИначеЕсли ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.Прочее") Тогда
			
			Возврат БиблиотекаКартинок.CRM_ПрочееСобытиеИсходящее;
			
		ИначеЕсли ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.ПочтовоеПисьмо") Тогда
			
			Возврат БиблиотекаКартинок.CRM_ПочтовоеПисьмоИсходящее;
			
		ИначеЕсли ВидСобытия = ПредопределенноеЗначение("Перечисление.CRM_ВидыСобытий.ЭлектронноеПисьмо") Тогда
			
			Возврат БиблиотекаКартинок.CRM_ЭлектронноеПисьмоИсходящее;
			
		Иначе
			
			Возврат БиблиотекаКартинок.CRM_ПрочееСобытиеИсходящее;
			
		КонецЕсли;
		
	КонецЕсли;
КонецФункции // ПолучитьКартинкуВидаСобытия()

// Функция формирует дату из даты и времени.
//
// Параметры:
//	ПараметрДата	- Дата	- Дата
//	ПараметрВремя	- Дата	- Время
//
// Возвращаемое значение:
//	Дата	- Дата
//
Функция СформироватьДатуИзДатыИВремени(ПараметрДата, ПараметрВремя) Экспорт
	Возврат НачалоДня(ПараметрДата) + (ПараметрВремя - Дата("00010101"));
КонецФункции // СформироватьДатуИзДатыИВремени()

// Функция разделяет дату на дату и время, возвращает структуру с полями "Дата", "Время".
//
// Параметры:
//	ПараметрДата	- Дата	- Дата
//
// Возвращаемое значение:
//	Структура	- Структура с датой м временем.
//
Функция РазделитьДатаНаДатуИВремя(ПараметрДата) Экспорт
	Возврат Новый Структура("Дата,Время", НачалоДня(ПараметрДата), Дата("00010101") + (ПараметрДата - НачалоДня(ПараметрДата)));
КонецФункции // РазделитьДатаНаДатуИВремя()

// Функция возвращает представление периода времени (1,5 часа, 6 часов, 30 минут, ...).
//
// Параметры:
//	ВремяНачало		- Дата	- Время начала.
//	ВремяОкончание	- Дата	- Время окончания.
//
// Возвращаемое значение:
//	Строка	- Представление времени.
//
Функция ПолучитьПредставлениеПериодаВремени(ВремяНачало, ВремяОкончание)
	ПустаяДата = Дата("00010101");
	// На случай если время содержит так же и дату.
	ЗначениеВремяНачало		= ПустаяДата + (ВремяНачало - НачалоДня(ВремяНачало));
	ЗначениеВремяОкончание	= ПустаяДата + (ВремяОкончание - НачалоДня(ВремяОкончание));
	ВремяНачалоВМинутах		= Цел((ЗначениеВремяНачало - НачалоДня(ЗначениеВремяНачало)) / 60);
	ВремяОкончанияВМинутах	= Цел((ЗначениеВремяОкончание - НачалоДня(ЗначениеВремяОкончание)) / 60);
	РазницаВМинутах = ВремяОкончанияВМинутах - ВремяНачалоВМинутах;
	Если РазницаВМинутах <= 0 Тогда
		Возврат "";
	КонецЕсли;
	// 1 минута
	// 2 - 4 минуты
	// 5 и далее - минут
	// 1 час
	// 2 - 4 часа
	// 5 часов
	// 5,5 часов
	Если РазницаВМинутах < 60 Тогда
		ВремяСтрокой = Формат(РазницаВМинутах, "ЧДЦ=0; ЧН=0; ЧГ=");
		Если РазницаВМинутах = 1 Тогда
			ПредставлениеВремя = НСтр("ru = 'минута'");
		ИначеЕсли РазницаВМинутах <= 4 Тогда
			ПредставлениеВремя = НСтр("ru = 'минуты'");
		Иначе
			ПредставлениеВремя = НСтр("ru = 'минут'");
		КонецЕсли;
	Иначе
		РазницаВЧасах = РазницаВМинутах / 60;
		Если РазницаВЧасах = Цел(РазницаВМинутах / 60) Тогда
			ВремяСтрокой = Формат(РазницаВЧасах, "ЧДЦ=0; ЧРД=,; ЧН=0; ЧГ=");
		Иначе
			ВремяСтрокой = Формат(РазницаВЧасах, "ЧДЦ=1; ЧРД=,; ЧН=0; ЧГ=");
		КонецЕсли;
		Если РазницаВЧасах = 1 Тогда
			ПредставлениеВремя = НСтр("ru = 'час'");
		ИначеЕсли РазницаВЧасах <= 4 Тогда
			ПредставлениеВремя = НСтр("ru = 'часа'");
		Иначе
			ПредставлениеВремя = НСтр("ru = 'часов'");
		КонецЕсли;
	КонецЕсли;
	Возврат ВремяСтрокой + " " + ПредставлениеВремя;
КонецФункции // ПолучитьПредставлениеПериодаВремени()

// Процедура заполняет список выбора для поля ввода времени.
//
// Параметры:
//	Список								- СписокЗначений	- Список выбора элемента формы.
//	ВремяНачало							- Дата				- Время с которого формируется список.
//	ДобавлятьПредставлениеДлительности	- Булево			- Признак добавления в список представления длительности.
//
Процедура ЗаполнитьСписокВыбораВремени(Список, ВремяНачало = Неопределено, ДобавлятьПредставлениеДлительности = Ложь) Экспорт
	
	Список.Очистить();
	ПустаяДата = Дата("00010101");
	бДобавлятьПредставлениеДлительности = (ДобавлятьПредставлениеДлительности И ТипЗнч(ВремяНачало) = Тип("Дата"));
	
	Если бДобавлятьПредставлениеДлительности Тогда
		// Если ВремяНачало содержит так же и дату.
		ЗначениеВремяНачало = ПустаяДата + (ВремяНачало - НачалоДня(ВремяНачало));
	Иначе
		ЗначениеВремяНачало = Неопределено
	КонецЕсли;
	
	ТекВремя = ?(ЗначениеВремяНачало = Неопределено, ПустаяДата, ЗначениеВремяНачало + 30 * 60);
	
	Пока НачалоДня(ТекВремя) <= НачалоДня(ПустаяДата) Цикл
		ПредставлениеВремени = Формат(ТекВремя, "ДФ=HH:mm; ДП=00:00");
		
		Если бДобавлятьПредставлениеДлительности Тогда
			ПредставлениеПериодаВремени = ПолучитьПредставлениеПериодаВремени(ЗначениеВремяНачало, ТекВремя);
			Если ЗначениеЗаполнено(ПредставлениеПериодаВремени) Тогда
				ПредставлениеВремени = ПредставлениеВремени + " (" + ПредставлениеПериодаВремени + ")";
			КонецЕсли;
		КонецЕсли;
		
		Список.Добавить(ТекВремя, ПредставлениеВремени);
		ТекВремя = ТекВремя + 30 * 60;
		
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьСписокВыбораВремени()

// Функция открывает список для выбора времени.
//
// Параметры:
//	Форма								- УправляемаяФорма	- Форма
//	СтароеЗначение						- Дата				- Старое значение времени.
//	ЭлементФормы						- ЭлементУправления	- Элемент формы.
//	ВремяНачало							- Дата				- Время, с которого формируется список.
//	ДобавлятьПредставлениеДлительности	- Булево			- Признак добавления в список представления длительности.
//
// Возвращаемое значение:
//	Неопределено или Дата	- Время.
//
Процедура ВыбратьВремяИзСписка(Форма, Знач СтароеЗначение, ЭлементФормы, ВремяНачало = Неопределено, ДобавлятьПредставлениеДлительности = Ложь, ОписаниеОповещения) Экспорт
	
	Список = Новый СписокЗначений();
	
	CRM_ОбщегоНазначенияКлиентСервер.ЗаполнитьСписокВыбораВремени(Список, ВремяНачало, ДобавлятьПредставлениеДлительности);
	СтароеЗначениеОкругленное = Дата("00010101") + ( Цел((СтароеЗначение - НачалоДня(СтароеЗначение)) / (30 * 60)) * (30 * 60) );
	СтароеЗначениеВСписке = Список.НайтиПоЗначению(СтароеЗначениеОкругленное);
	
	Если СтароеЗначениеВСписке = Неопределено Тогда
		Форма.ПоказатьВыборИзСписка(ОписаниеОповещения, Список, ЭлементФормы);
	Иначе
		Форма.ПоказатьВыборИзСписка(ОписаниеОповещения, Список, ЭлементФормы, СтароеЗначениеВСписке);
	КонецЕсли;
	
КонецПроцедуры // ВыбратьВремяИзСписка()

////////////////////////////////////////////////////////////////////////////////
// Отборы списков

// Процедура удаляет элемент отбора коллекции.
//
// Параметры:
//	КоллекцияЭлементов	- КоллекцияЭлементовОтбораКомпоновкиДанных	- Коллекция элементов.
//	ИмяПоля				- Строка									- Имя поля.
//
Процедура УдалитьЭлементОтбораКоллекции(КоллекцияЭлементов, ИмяПоля)
	
	ПолеКомпоновки = Новый ПолеКомпоновкиДанных(ИмяПоля);
	ИндексЭлементаОтбора = 0;
	
	Пока ИндексЭлементаОтбора < КоллекцияЭлементов.Количество() Цикл
		ЭлементОтбора = КоллекцияЭлементов[ИндексЭлементаОтбора];
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") 
		   И ЭлементОтбора.ЛевоеЗначение = ПолеКомпоновки Тогда
			
			КоллекцияЭлементов.Удалить(ЭлементОтбора);
			
		Иначе
			ИндексЭлементаОтбора = ИндексЭлементаОтбора + 1;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // УдалитьЭлементОтбораКоллекции()

// Процедура удаляет элемент отбора динамического списка.
//
// Параметры:
//	Список	- ДинамическийСписок	- Обрабатываемый динамический список,
//  ИмяПоля	- Строка				- Имя поля компоновки, отбор по которому нужно удалить.
//
Процедура УдалитьЭлементОтбораСписка(Список, ИмяПоля) Экспорт
	
	УдалитьЭлементОтбораКоллекции(Список.Отбор.Элементы, ИмяПоля);
	
КонецПроцедуры // УдалитьЭлементОтбораСписка()

// Процедура устанавливает элемент отбора коллекции.
//
// Параметры:
//	КоллекцияЭлементов	- КоллекцияЭлементовОтбораКомпоновкиДанных	- Коллекция элементов.
//	ИмяПоля				- Строка									- Имя поля.
//	ПравоеЗначение		- Произвольный								- Значение отбора.
//  ВидСравнения		- ВидСравненияКомпоновкиДанных             	- Вид сравнения.
//  Родитель			- ГруппаЭлементовОтбораКомпоновкиДанных     - Родитель добавляемой группы отбора.
//
Процедура УстановитьЭлементОтбораКоллекции(КоллекцияЭлементов, ИмяПоля, ПравоеЗначение, ВидСравнения = Неопределено, Родитель = Неопределено)
	
	Если Родитель = Неопределено Тогда
		ЭлементОтбора = КоллекцияЭлементов.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Иначе
		ЭлементОтбора = Родитель.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	КонецЕсли;
	ЭлементОтбора.ЛевоеЗначение    = Новый ПолеКомпоновкиДанных(ИмяПоля);
	ЭлементОтбора.ВидСравнения     = ?(ВидСравнения = Неопределено, ВидСравненияКомпоновкиДанных.Равно, ВидСравнения);
	ЭлементОтбора.Использование    = Истина;
	ЭлементОтбора.ПравоеЗначение   = ПравоеЗначение;
	ЭлементОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	
КонецПроцедуры // УстановитьЭлементОтбораКоллекции()

// Процедура устанавливает элемент отбора динамического списка.
//
// Параметры:
//	Список				- ДинамическийСписок						- Обрабатываемый динамический список,
//	ИмяПоля				- Строка									- Имя поля.
//	ПравоеЗначение		- Произвольный								- Значение отбора.
//  ВидСравнения		- ВидСравненияКомпоновкиДанных				- Вид сравнения.
//  Родитель			- ГруппаЭлементовОтбораКомпоновкиДанных     - Родитель добавляемой группы отбора.
//
Процедура УстановитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение, ВидСравнения = Неопределено, Родитель = Неопределено) Экспорт
	
	УстановитьЭлементОтбораКоллекции(Список.Отбор.Элементы, ИмяПоля, ПравоеЗначение, ВидСравнения, Родитель);	
	
КонецПроцедуры // УстановитьЭлементОтбораСписка()

// Процедура изменяет элемент отбора динамического списка.
//
// Параметры:
//	Список				- ДинамическийСписок			- Обрабатываемый динамический список,
//	ИмяПоля				- Строка						- Имя поля.
//	ПравоеЗначение		- Произвольный					- Значение отбора.
//  Установить			- Булево						- Признак необходимости установить отбор.
//  ВидСравнения		- ВидСравненияКомпоновкиДанных  - Вид сравнения.
//
Процедура ИзменитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение = Неопределено, Установить = Ложь, ВидСравнения = Неопределено) Экспорт
	
	УдалитьЭлементОтбораСписка(Список, ИмяПоля);
	
	Если Установить Тогда
		
		Если ТипЗнч(ПравоеЗначение) = Тип("СтандартныйПериод") Тогда
			
			Если ЗначениеЗаполнено(ПравоеЗначение.ДатаНачала) Тогда
				УстановитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение.ДатаНачала, ВидСравненияКомпоновкиДанных.БольшеИлиРавно);	
			КонецЕсли;
			
			Если ЗначениеЗаполнено(ПравоеЗначение.ДатаОкончания) Тогда
				УстановитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение.ДатаОкончания, ВидСравненияКомпоновкиДанных.МеньшеИлиРавно);	
			КонецЕсли;	
			
		Иначе	
			УстановитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение, ВидСравнения);
		КонецЕсли;
	КонецЕсли;
		
КонецПроцедуры // ИзменитьЭлементОтбораСписка()

Процедура ИзменитьЭлементОтбораГруппыСписка(Группа, ИмяПоля, ПравоеЗначение = Неопределено, Установить = Ложь, ВидСравнения = Неопределено) Экспорт
	
	УдалитьЭлементОтбораКоллекции(Группа.Элементы, ИмяПоля);
	
	Если Установить Тогда
		УстановитьЭлементОтбораКоллекции(Группа.Элементы, ИмяПоля, ПравоеЗначение, ВидСравнения);
	КонецЕсли;
	
КонецПроцедуры // ИзменитьЭлементОтбораСписка()

// Функция устанавливает группу отбора коллекции и возвращает созданную группу.
//
// Параметры:
//	КоллекцияЭлементов	- КоллекцияЭлементовОтбораКомпоновкиДанных	- Коллекция элементов.
//	ТипГруппы			- ТипГруппыЭлементовОтбораКомпоновкиДанных	- Тип группы отбора.
//
Функция УстановитьГруппуОтбораКоллекции(КоллекцияЭлементов, ТипГруппы) 
	
	ЭлементОтбора					= КоллекцияЭлементов.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	ЭлементОтбора.ТипГруппы			= ТипГруппы;
	ЭлементОтбора.РежимОтображения	= РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;	
	
	Возврат ЭлементОтбора;
	
КонецФункции // УстановитьЭлементОтбораКоллекции()

// Функция-ретранслятор устанавливает группу отбора динамического списка.
//
// Параметры:
//	Список				- ДинамическийСписок						- Обрабатываемый динамический список,
//	ТипГруппы			- ТипГруппыЭлементовОтбораКомпоновкиДанных	- Тип группы отбора.
//  Родитель			- ГруппаЭлементовОтбораКомпоновкиДанных     - Родитель добавляемой группы отбора.
//
Функция УстановитьГруппуОтбораСписка(Список, ТипГруппы, Родитель = Неопределено) Экспорт
	
	Если Родитель = Неопределено Тогда
		Возврат УстановитьГруппуОтбораКоллекции(Список.Отбор.Элементы, ТипГруппы);		
	Иначе		
		Возврат УстановитьГруппуОтбораКоллекции(Родитель.Элементы, ТипГруппы);
	КонецЕсли;		
	
КонецФункции	

////////////////////////////////////////////////////////////////////////////////
// Блок функций для работы с почтовыми адресами.
//

// Функция сдвигает маркер позиции пока встречается символ Символ.
// Возвращает номер позиции в строке, на которое установился маркер.
//
// Параметры:
//	Строка				- Строка	- Строка
//	ТекущийИндекс		- Число		- Текущий индекс в строке.
//	ПропускаемыйСимвол	- Строка	- Пропускаемый символ.
//
// Возвращаемое значение:
//	Число	- Текущий индекс
//
Функция ПропуститьПробелы(знач Строка, знач ТекущийИндекс, знач ПропускаемыйСимвол)
	Результат = ТекущийИндекс;
	// Убираем лишние пробелы если они есть.
	Пока ТекущийИндекс < СтрДлина(Строка) Цикл
		Если Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол Тогда
			Возврат ТекущийИндекс;
		КонецЕсли;
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	Возврат ТекущийИндекс;
КонецФункции // ПропуститьПробелы()

// Функция проверяет правильность введенной строки с e-mail адресом.
//
// Параметры:
//	СтрокаАдреса	- Строка	- Строка адреса.
//
// Возвращаемое значение:
//	Структура	- Структура результата.
//
Функция РазобратьСтрокуСПочтовымАдресом(знач СтрокаАдреса) Экспорт
	
	
	Отказ		= Ложь;
	Результат	= Новый Структура;
	
	//Если ЗначениеЗаполнено(СтрокаАдреса) Тогда
	//	Результат.Вставить("Отказ",Отказ);
	//	Возврат Результат;
	//КонецЕсли;
	
	НедопустимыеСимволы	= "!#$%^&*()+`~|\/=;,";
	
	// Убрана проверка на символы русского алфавита, если нужно будет вернуть обратно - раскомментировать.
	СимволыРусскогоАлфавита		= "";
	//СимволыРусскогоАлфавита		= "ёйцукенгшщзхъфывапролджэячсмитьбю";
	
	СимволыЛатинскогоАлфавита = "qwertyuiopasdfghjklzxcvbnm";
	СимволыЦифры ="0123456789";
	
	
	Индекс = 1;               // Номер обрабатываемого символа.
	Накопитель = "";          // Накопитель символов, после анализа перемещается либо в полное имя
							  // либо в почтовый адрес.
	ПолноеИмяАдресата = "";   // Переменная, накапливающая имя адресата.
	ПочтовыйАдрес = "";       // Переменная, накапливающая e-mail адрес.
	
	Логин = "";              
	Домен = Новый Массив;;              // Например yandex
	НациональныйДомен = "";  // Например ru
	ТекущийНомерДомена = 0;
	ПустойДомен = Ложь;
	СтадияРазбора = 1;
	ПробелВначале = Ложь;
	СообщениеНедопустимыеСимволы			= НСтр("ru = 'Недопустимые символы в адресе электронной почты.
														 |Адреса электронной почты не должен содержать: !#$%^&*()+`~|\/=;,'");
	СообщениеНеверныйФорматПочтовогоАдреса	= НСтр("ru = 'Неверный формат адреса электронной почты.'");
	СообщениеПробелВСтроке					= НСтр("ru = 'Адреса электронной почты не должены содержать пробелов.'");
	СообщениеСимволыРусскогоАлфавита					= НСтр("ru = 'Адреса электронной почты должны состоять из букв английского алфавита'");
	СообщениеПустоеДоменноеИмя				= НСтр("ru = 'Доменное имя не может быть пустым'");
	ПредыдущийСимвол ="";
	
	Пока Индекс <= СтрДлина(СтрокаАдреса) Цикл
		Символ = Сред(СтрокаАдреса, Индекс, 1);
		ЭтоЦифра = (Найти(СимволыЦифры, НРег(Символ)) > 0);
		ЭтоСимволАлфавита = (Найти(СимволыЛатинскогоАлфавита, НРег(Символ)) > 0);
		ЭтоДругойСимвол = (?(ЭтоЦифра = Ложь И ЭтоСимволАлфавита = Ложь,Истина,Ложь));
		Если Символ = " " Тогда
			
			Если (Индекс = 1) Тогда
				ПробелВначале = Истина;
			ИначеЕсли (Индекс = СтрДлина(СтрокаАдреса)) Тогда 
				// Ничего не делаем, если пробел стоит вначале или конце строки, то это не критично.
			ИначеЕсли НЕ Сред(СтрокаАдреса, ПропуститьПробелы(СтрокаАдреса, Индекс, " "), 1) = " " Тогда
				Отказ = Истина;
				Результат.Вставить("Отказ",Отказ);
				Результат.Вставить("Сообщение",СообщениеПробелВСтроке);
				Возврат Результат;
			КонецЕсли;
			
		ИначеЕсли НЕ ЭтоДругойСимвол Тогда
			Если СтадияРазбора = 1 Тогда
				Логин = Логин + Символ;
			ИначеЕсли СтадияРазбора = 2 Тогда
				Домен[ТекущийНомерДомена] = Строка(Домен[ТекущийНомерДомена])+Строка(Символ);
			КонецЕсли;
		ИначеЕсли Символ = "." Тогда
			Если СтадияРазбора = 2 Тогда
				Если (ПредыдущийСимвол = "." ИЛИ ПредыдущийСимвол = "@") Тогда 
					ПустойДомен = Истина;
				ИначеЕсли СтадияРазбора = 2 Тогда
					Домен.Добавить();
					ТекущийНомерДомена = ТекущийНомерДомена + 1;
				КонецЕсли; 
			КонецЕсли;	
		ИначеЕсли Символ = "@" Тогда
			Домен.Добавить();
			Если СтадияРазбора = 1 Тогда
				СтадияРазбора = 2;
			ИначеЕсли СтадияРазбора = 2 Тогда
				Отказ = Истина;
				Результат.Вставить("Отказ",Отказ);
				Результат.Вставить("Сообщение",СообщениеНеверныйФорматПочтовогоАдреса);
				Возврат Результат;
			КонецЕсли;
	 
		ИначеЕсли Найти(НедопустимыеСимволы, Символ) > 0 Тогда
			Отказ = Истина;
			Результат.Вставить("Отказ",Отказ);
			Результат.Вставить("Сообщение",СообщениеНедопустимыеСимволы);
			Возврат Результат;
		ИначеЕсли Найти(СимволыРусскогоАлфавита, НРег(Символ)) > 0 Тогда
			Отказ = Истина;
			Результат.Вставить("Отказ",Отказ);
			Результат.Вставить("Сообщение",СообщениеСимволыРусскогоАлфавита);
			Возврат Результат;
		КонецЕсли;
		Индекс = Индекс + 1;
		ПредыдущийСимвол = Символ;
	КонецЦикла;
	
	Если Логин="" И Домен.Количество()>1 Тогда
		Отказ = Истина;
		Результат.Вставить("Отказ",Отказ);
		Результат.Вставить("Сообщение",СообщениеНеверныйФорматПочтовогоАдреса);
	КонецЕсли;
	КоличествоДоменов = Домен.Количество();
	Ошибка = (КоличествоДоменов =1 )
		ИЛИ (ПробелВначале И Логин =  "")
		ИЛИ (ЛОгин =  "" И КоличествоДоменов > 0)
		ИЛИ (КоличествоДоменов > 1 И Строка(Домен[Домен.Количество()-1]) = "")
		ИЛИ (Логин <> "" И СтрЧислоВхождений(СтрокаАдреса,"@") <> 1);
	Если Ошибка Тогда
		Отказ = Истина;
		Результат.Вставить("Отказ",Отказ);
		Результат.Вставить("Сообщение",СообщениеНеверныйФорматПочтовогоАдреса);
	КонецЕсли; 
	
	Результат.Вставить("Отказ", Отказ);
	Возврат Результат;
КонецФункции // РазобратьСтрокуСПочтовымАдресом()

// Функция преобразует переданный текст в HTML-текст.
//
// Параметры:
//	Текст		- Строка	- Текст
//	ТолькоТекст	- Булево	- Флаг преобразования только текста.
//
// Возвращаемое значение:
//
//
Функция ПреобразоватьТекстВHTML(Текст, ТолькоТекст = Ложь) Экспорт
	
	Результат = "";
	Результат = Текст;
	Результат = СтрЗаменить(Результат, Символы.Таб,"&nbsp; &nbsp; &nbsp;");
	Результат = СтрЗаменить(Результат, Символы.ПС,"<P>");

	Результат = СтрЗаменить(Результат, "#Начало#", 			"<span style=' font-weight: bold; color: #800000;'>");
	Результат = СтрЗаменить(Результат, "#Конец#", 			"</span>");
	Результат = СтрЗаменить(Результат, "#СсылкаНачало#", 	"<a href='mailto:");
	Результат = СтрЗаменить(Результат, "#СсылкаСередина#", 	"'><span style='color: #0000ff;'>");
	Результат = СтрЗаменить(Результат, "#СсылкаКонец#", 	"</span></a>");
	Результат = СтрЗаменить(Результат, "#НачалоКартинки#", 	"<");
	Результат = СтрЗаменить(Результат, "#КонецКартинки#", 	">");	
	Результат = СтрЗаменить(Результат, "#НачалоСсылки#",    "<");
	Результат = СтрЗаменить(Результат, "#КонецСсылки#",     ">"); 
	Результат = СтрЗаменить(Результат, "#КонецСсылкиЗакрывающийТегА#", "</a>"); 
	Результат = "<P>" + Результат + "</P>";
	Если НЕ ТолькоТекст Тогда
		ФорматХТМЛ =" 
		|<html>
		|<head>
		|<meta http-equiv=Content-Type content=" + """" + "text/html; charset=utf-8"">
		|<title></title>
		|</head>
		|<body>
		|" + Результат + "
		|</body>
		|</html>";
	Иначе
		ФорматХТМЛ = Результат;
	КонецЕсли;
	Возврат ФорматХТМЛ; 
КонецФункции // ПреобразоватьТекстВHTML()

// На входе строка "абвг" на выходе: возврат "а", стр = "бвг".
Функция ПропуститьПробелыВНачале(стр)

	Возврат СокрЛП(стр);

КонецФункции 

Функция ПолучитьСледСимвол(стр)

	Символ = Сред(стр,1,1);
	стр = Сред(стр,2,СтрДлина(стр)-1);
	Возврат Символ;
КонецФункции // ()

Функция ПолучитьЛогин(Текст,ТекущийСимвол,Терм_Конец,НедопустимыеСимволы,СимволыРусскогоАлфавита = "")

	СтруктураВозврата = Новый Структура("Логин,КодОшибки");
	ВыходСтрока = "";
	Пока ТекущийСимвол <> Терм_Конец Цикл
		Если ТекущийСимвол = "" Тогда
			// Логин завершили считывать, а домен еще даже не начали.
			СтруктураВозврата.КодОшибки = 2;
			Возврат СтруктураВозврата;
		КонецЕсли;
		Если ТекущийСимвол = " " Тогда
			// Пробел в имени?
			СтруктураВозврата.КодОшибки = 2;
			Возврат СтруктураВозврата;
		КонецЕсли;
		Если Найти(НедопустимыеСимволы,ТекущийСимвол) Тогда
			СтруктураВозврата.КодОшибки = 1;
			Возврат СтруктураВозврата;
		КонецЕсли;
		Если Найти(СимволыРусскогоАлфавита,ТекущийСимвол) Тогда
			СтруктураВозврата.КодОшибки = 4;
			Возврат СтруктураВозврата;
		КонецЕсли;
		ВыходСтрока = ВыходСтрока + ТекущийСимвол;
		ТекущийСимвол = ПолучитьСледСимвол(Текст);
	КонецЦикла;
	Если СтрДлина(ВыходСтрока) = 0 Тогда
		// Логин пустым не бывает
		СтруктураВозврата.КодОшибки = 4;
		Возврат СтруктураВозврата;
	КонецЕсли;
	СтруктураВозврата.КодОшибки = 0;
	СтруктураВозврата.Логин = ВыходСтрока;
	Возврат СтруктураВозврата;
КонецФункции

Функция ПолучитьДомены(Текст,ТекущийСимвол,Терм_Конец,НедопустимыеСимволы,СимволыРусскогоАлфавита = "")
	
	СтруктураВозврата = Новый Структура("Домены,КодОшибки");
	МассивДоменов = Новый Массив(4);
	ТекущийСимвол = ПолучитьСледСимвол(Текст);
	ТекущийДомен = "";
	НомТекущегоДомена = 0;
	Если ТекущийСимвол = "." ИЛИ ТекущийСимвол = "" Тогда
			СтруктураВозврата.КодОшибки = 5;
			Возврат СтруктураВозврата;
	КонецЕсли;
	КоличествоДомИмен = 0;
	Пока ТекущийСимвол<>Терм_Конец Цикл
		// Если у нас первый символ начинается на точку те @.dudud.ru или @dududu..ru.
		// Пока доменное имя пусто
		Пока ТекущийСимвол<>"." И ТекущийСимвол<>Терм_Конец Цикл
			Если Найти(НедопустимыеСимволы,ТекущийСимвол) Тогда
				СтруктураВозврата.КодОшибки = 1;
				Возврат СтруктураВозврата;
			КонецЕсли;
			Если Найти(СимволыРусскогоАлфавита,ТекущийСимвол) Тогда
				СтруктураВозврата.КодОшибки = 4;
				Возврат СтруктураВозврата;
			КонецЕсли;
			// Пробелов тоже не должно быть в доменном имени.
			Если ТекущийСимвол=" " Тогда
				СтруктураВозврата.КодОшибки = 2;
				Возврат СтруктураВозврата;
			КонецЕсли;
			ТекущийДомен = ТекущийДомен+ТекущийСимвол;
			ТекущийСимвол = ПолучитьСледСимвол(Текст);
			//ПустойДомен = Ложь;
		КонецЦикла;
		ПредСимвол = ТекущийСимвол;
		МассивДоменов.Вставить(НомТекущегоДомена,ТекущийДомен);
		КоличествоДомИмен = КоличествоДомИмен+1;
		ТекущийДомен = "";
		НомТекущегоДомена = НомТекущегоДомена + 1;
		ТекущийСимвол = ПолучитьСледСимвол(Текст);
		Если ПредСимвол ="." И (ТекущийСимвол = "." ИЛИ ТекущийСимвол = "") Тогда
			СтруктураВозврата.КодОшибки = 5;
			Возврат СтруктураВозврата;
		КонецЕсли;
	КонецЦикла;
	Если КоличествоДомИмен < 2 Тогда
		СтруктураВозврата.КодОшибки = 2;
		Возврат СтруктураВозврата;
	КонецЕсли; 
	
	СтруктураВозврата.Домены = МассивДоменов;
	СтруктураВозврата.КодОшибки = 0;
	Возврат СтруктураВозврата;
КонецФункции // ()

// На выходе получаем структуру "Представление,Логин,Домены,Сообщение,КодОшибки".
// Домены - массив
Функция АнализАдресаЭП(Знач Адрес)Экспорт
	// Выходные значения 
	Представление = "";
	Логин = "";
	Домены = Новый Массив(4);
	ВозврСтруктура = Новый Структура("АдресЭП,Представление,Логин,Домены,Сообщение,КодОшибки","","",Домены,"",0);
	// Нечего анализировать = возвращаем, что все ок с кодом ошибки 0.
	Если Адрес = "" Тогда
		ВозврСтруктура.КодОшибки = 0;
		Возврат ВозврСтруктура;
	КонецЕсли;
	// Коды Ошибок
	СообщениеНедопустимыеСимволы			= НСтр("ru = 'Недопустимые символы в адресе электронной почты.
	|Адреса электронной почты не должен содержать: !#$%^&*()+`~|\/=;,'");
	СообщениеНеверныйФорматПочтовогоАдреса	= НСтр("ru = 'Неверный формат адреса электронной почты.'");
	СообщениеПробелВСтроке					= НСтр("ru = 'Адреса электронной почты не должены содержать пробелов.'");
	СообщениеСимволыРусскогоАлфавита		= НСтр("ru = 'Адреса электронной почты должны состоять из букв английского алфавита'");
	СообщениеПустоеДоменноеИмя				= НСтр("ru = 'Доменное имя не может быть пустым'");
	МассивСообщений = Новый Массив(6);
	МассивСообщений.Вставить(1,СообщениеНедопустимыеСимволы);
	МассивСообщений.Вставить(2,СообщениеНеверныйФорматПочтовогоАдреса);
	МассивСообщений.Вставить(3,СообщениеПробелВСтроке);
	МассивСообщений.Вставить(4,СообщениеСимволыРусскогоАлфавита);
	МассивСообщений.Вставить(5,СообщениеПустоеДоменноеИмя);
	
	
	// Символы 
	НедопустимыеСимволы	= "!#$%^&*()+`~|\/=;,";
	
	// Убрана проверка на символы русского алфавита, если нужно будет вернуть обратно - раскомментировать.
	СимволыРусскогоАлфавита		= "";
	//СимволыРусскогоАлфавита		= "ёйцукенгшщзхъфывапролджэячсмитьбю";
	
	СимволыЛатинскогоАлфавита = "qwertyuiopasdfghjklzxcvbnm";
	СимволыЦифры ="0123456789";
	
	Терм_Домен = "@";
	Текст = ПропуститьПробелыВНачале(Адрес);
	// Смотрим имеется ли представление.
	ПозицияНачалаАдреса = Найти(Текст, "<");
	Если ПозицияНачалаАдреса > 0 Тогда
		
		ПозицияОкончанияАдреса = Найти(Текст, ">");
		
		Если ПозицияОкончанияАдреса < ПозицияНачалаАдреса Тогда
			
			ВозврСтруктура.КодОшибки = 1;
			
			ВозврСтруктура.Сообщение = МассивСообщений[1];
			
			Возврат ВозврСтруктура;		
			
		КонецЕсли;
		
		ВозврСтруктура.Представление = СокрЛП(Лев(Текст, ПозицияНачалаАдреса - 1));
		
		Текст = ПропуститьПробелыВНачале(Сред(Текст, ПозицияНачалаАдреса + 1, ПозицияОкончанияАдреса - ПозицияНачалаАдреса - 1));
	Иначе
		ПозицияОкончанияАдреса = Найти(Текст, ">");
		Если ПозицияОкончанияАдреса > 0 Тогда
			
			ВозврСтруктура.КодОшибки = 1;
			
			ВозврСтруктура.Сообщение = МассивСообщений[1];
			
			Возврат ВозврСтруктура;
			
		КонецЕсли;
		Текст = СтрЗаменить(Текст, ";", "");
	КонецЕсли;
	
	ТекущийСимвол = ПолучитьСледСимвол(Текст);
	
	// Если нет представления разбираем адрес на логин и домены.
	// Сначала разбираем логин
	СтрЛогин = ПолучитьЛогин(Текст,ТекущийСимвол,Терм_Домен,НедопустимыеСимволы,СимволыРусскогоАлфавита);
	Если СтрЛогин.КодОшибки = 0 Тогда
		// Все в порядке продолжаем
		// Пытаемся получить домены
		ВозврСтруктура.Логин = СтрЛогин.Логин;
		СтрДомены = ПолучитьДомены(Текст,ТекущийСимвол,"",НедопустимыеСимволы,СимволыРусскогоАлфавита);
		Если СтрДомены.КодОшибки = 0 Тогда
			// Тогда все хорошо и можно завершить разбор.
			ВозврСтруктура.Домены = СтрДомены.Домены;
			// ПолучимСтроку адреса электронной почты.
			СтрДоменов = "";
			Для каждого Домен Из ВозврСтруктура.Домены Цикл
				Если ЗначениеЗаполнено(Домен) Тогда
				
					СтрДоменов = СтрДоменов + Домен + ".";
				КонецЕсли;
			КонецЦикла;
			СтрДоменов = Сред(СтрДоменов,1,СтрДлина(СтрДоменов)-1);
			ВозврСтруктура.АдресЭП = ВозврСтруктура.Логин +"@"+СтрДоменов;
			ВозврСтруктура.КодОшибки = 0;
			Возврат ВозврСтруктура;
		Иначе
			ВозврСтруктура.КодОшибки = СтрДомены.КодОшибки;
			ВозврСтруктура.Сообщение = МассивСообщений[СтрДомены.КодОшибки];
			Возврат ВозврСтруктура;
		КонецЕсли;
	Иначе
		// Иначе ругаемся
		ВозврСтруктура.Сообщение = МассивСообщений[СтрЛогин.КодОшибки];
		ВозврСтруктура.КодОшибки = СтрЛогин.КодОшибки;
		Возврат ВозврСтруктура;
	КонецЕсли;
	ВозврСтруктура.КодОшибки = 10;
	Возврат ВозврСтруктура;
КонецФункции

// Функция анализирует строку адресов электронной почты.
//
Функция АнализСтрокиАдресовЭП(Знач СтрокаАдресов,СимволРазделитель =",",ЕстьОшибки)Экспорт
	
	ВозвратМассив = Новый Массив;
	
	СтрокаАдресов = СтрЗаменить(СтрокаАдресов,">,", ">" + СимволРазделитель);
	СтрокаАдресов = СтрЗаменить(СтрокаАдресов,"> ,", ">" + СимволРазделитель);
	
	МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаАдресов,СимволРазделитель,Истина);
	
	
	СборнаяСтрокаАдреса = "";
	Для Каждого Адрес Из МассивПодстрок Цикл
		
		Если Найти(Адрес, "@") = 0 Тогда
			СборнаяСтрокаАдреса = СборнаяСтрокаАдреса + ?(СборнаяСтрокаАдреса = "","",",") + Адрес;
		Иначе
			СборнаяСтрокаАдреса = СборнаяСтрокаАдреса + ?(СборнаяСтрокаАдреса = "","",",") + Адрес;
			
			СтруктураСтроки = Новый Структура("АдресЭП,Представление,Логин,Домены,Сообщение,КодОшибки");
			//СтруктураВозврата = АнализАдресаЭП(Адрес);
			СтруктураВозврата = АнализАдресаЭП(СборнаяСтрокаАдреса);
			ЗаполнитьЗначенияСвойств(СтруктураСтроки, СтруктураВозврата);
			ВозвратМассив.Добавить(СтруктураВозврата);
			Ошибка = ?(СтруктураВозврата.КодОшибки = 0,Ложь,Истина);
			ЕстьОшибки = ЕстьОшибки ИЛИ Ошибка;
			
			СборнаяСтрокаАдреса = "";
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ СборнаяСтрокаАдреса = "" Тогда
		СтруктураСтроки = Новый Структура("АдресЭП,Представление,Логин,Домены,Сообщение,КодОшибки");
		СтруктураВозврата = АнализАдресаЭП(СборнаяСтрокаАдреса);
		ЗаполнитьЗначенияСвойств(СтруктураСтроки, СтруктураВозврата);
		ВозвратМассив.Добавить(СтруктураВозврата);
		Ошибка = ?(СтруктураВозврата.КодОшибки = 0,Ложь,Истина);
		ЕстьОшибки = ЕстьОшибки ИЛИ Ошибка;
	КонецЕсли;
	
	Возврат ВозвратМассив;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Блок процедур и функций для работы с настройками полей отображения содержания.

// Функция возвращает пустое содержание.
//
// Параметры:
//	СсылкаНаОбъект	 - Произвольный	- Ссылка на объект.
//	ТекстКомментария - Строка - доп. текст в качестве комментария "пустого" содержания.
//
// Возвращаемое значение:
//	Строка	- Пустое содержание
//
Функция НастройкиПолейОтображенияСодержанияПолучитьПустоеСодержание(СсылкаНаОбъект = Неопределено, ТекстКомментария = "") Экспорт
	ГиперссылкаНастройки = "<FONT size=""1""><br><hr noshade size=""1""></FONT><DIV align=""right""><FONT size=""1""><A style=""COLOR: #594304"" href=""НастройкаПолейОтображения"">" + НСтр("ru = 'Настройка'") + "</A></FONT></DIV>";
	//ГиперссылкаЗаполнить = ?(ЗначениеЗаполнено(ТекстКомментария), "", "<DIV align=""right""><FONT size=""1""><A style=""COLOR: #594304"" href=""ЗаполнитьПоУмолчанию"">" + НСтр("ru = 'Заполнить список полей содержания по умолчанию'") + "</A></FONT></DIV>");
	Описание =
	"<html>
	|<head>
	|<meta http-equiv=Content-Type content=" + """" + "text/html; charset=utf-8"">
	|<title></title>
	|</head>
	|<body>
	|" + ТекстКомментария +	ГиперссылкаНастройки + "
	//?(ЗначениеЗаполнено(ГиперссылкаЗаполнить), "
	//|" + ГиперссылкаЗаполнить, "") + "
	|</body>
	|</html>";
	Возврат Описание;
КонецФункции // НастройкиПолейОтображенияСодержанияПолучитьПустоеСодержание()

// Функция возвращает структуру.
// Структура{
// Представление - наименование цвета.
// Цвет - значение типа Цвет
// }
// Если не найдено возвращает Неопределено.
Функция ПолучитьЦветПоКлючу(Ключ) Экспорт

	Цвета = ПолучитьСписокЦветов();
	эЦвет = Неопределено;
	
	Если ТипЗнч(Ключ) = Тип("Число") Тогда
		
		зЦвет = Цвета.Получить(Ключ);
		Возврат зЦвет;
	ИначеЕсли ТипЗнч(Ключ) = Тип("Цвет") Тогда
		Для каждого эЦвет Из Цвета Цикл
			Если эЦвет.Цвет = Ключ Тогда
				Возврат эЦвет;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	Возврат эЦвет;
КонецФункции // ПолучитьЦветПоКлючу(Ключ)()

// Функция возвращает соответствие ключ-значение.
// Ключ - номер картинки в коллекции.
// Структура{
// Представление - наименование цвета.
// Цвет - значение типа Цвет
// }
Функция ПолучитьСписокЦветов() Экспорт

	СоответствиеЦвет = Новый Соответствие;
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Красный'"));
	сЦвет.Вставить("Цвет",Новый Цвет(255,136,124));
	СоответствиеЦвет.Вставить(0,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Оранжевый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(255,184,120));
	СоответствиеЦвет.Вставить(1,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Персиковый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(251,215,91));
	СоответствиеЦвет.Вставить(2,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Желтый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(255,250,130));
	СоответствиеЦвет.Вставить(3,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Зеленый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(122,231,191));
	СоответствиеЦвет.Вставить(4,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Сине-зеленый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(70,214,219));
	СоответствиеЦвет.Вставить(5,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Оливковый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(197,210,169));
	СоответствиеЦвет.Вставить(6,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Синий'"));
	сЦвет.Вставить("Цвет",Новый Цвет(164,189,252));
	СоответствиеЦвет.Вставить(7,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Лиловый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(219,173,255));
	СоответствиеЦвет.Вставить(8,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Бордовый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(212,164,186));
	СоответствиеЦвет.Вставить(9,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Стальной'"));
	сЦвет.Вставить("Цвет",Новый Цвет(216,218,229));
	СоответствиеЦвет.Вставить(10,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Темно-стальной'"));
	сЦвет.Вставить("Цвет",Новый Цвет(97,111,140));
	СоответствиеЦвет.Вставить(11,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Светло-серый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(225,225,225));
	СоответствиеЦвет.Вставить(12,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Темно-серый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(104,104,104));
	СоответствиеЦвет.Вставить(13,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Черный'"));
	сЦвет.Вставить("Цвет",Новый Цвет(46,46,46));
	СоответствиеЦвет.Вставить(14,сЦвет);

	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Темно-красный'"));
	сЦвет.Вставить("Цвет",Новый Цвет(220,33,39));
	СоответствиеЦвет.Вставить(15,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Темно-оранжевый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(206,93,17));
	СоответствиеЦвет.Вставить(16,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Темно-персиковый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(192,145,32));
	СоответствиеЦвет.Вставить(17,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Темно-желтый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(175,170,0));
	СоответствиеЦвет.Вставить(18,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Темно-зеленый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(81,183,73));
	СоответствиеЦвет.Вставить(19,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Темно-бирюзовый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(53,149,119));
	СоответствиеЦвет.Вставить(20,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Картинка",21);
	сЦвет.Вставить("Представление",НСтр("ru = 'Темно-оливковый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(114,130,71));
	СоответствиеЦвет.Вставить(21,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Темно-синий'"));
	сЦвет.Вставить("Цвет",Новый Цвет(52,103,184));
	СоответствиеЦвет.Вставить(22,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Темно-лиловый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(91,61,160));
	СоответствиеЦвет.Вставить(23,сЦвет);
	
	сЦвет = Новый Структура;
	сЦвет.Вставить("Представление",НСтр("ru = 'Темно-бордовый'"));
	сЦвет.Вставить("Цвет",Новый Цвет(147,67,108));
	СоответствиеЦвет.Вставить(24,сЦвет);
	
	Возврат СоответствиеЦвет;
	
КонецФункции // ПолучитьСписокЦветов()

//////////////////////////////////////////////////////////////////////////////////
// ОТБОР ПО РЕКВИЗИТУ

Процедура УстановитьОтборПоРеквизиту(ЭтаФорма, ОбластьПоиска, ИмяПоля ,ИмяОтбора, Значение = Неопределено) Экспорт 
	
	Если ЗначениеЗаполнено(Значение) Тогда
		
		ЭтаФорма[ИмяПоля] = Значение;
		
		УстановитьЭлементОтбора(ОбластьПоиска,
							ИмяОтбора,
							ЭтаФорма[ИмяПоля],
							ВидСравненияКомпоновкиДанных.Равно,
							,Истина);	
	КонецЕсли;
						
КонецПроцедуры

// Используется для создания элемента отбора или, если таковой не найден,
// установления существующим элементам свойств.
// Параметры:
//  ОбластьПоискаДобавления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе.
//  ИмяПоля - строка - имя для поля компоновки данных (заполняется всегда).
// Устанавливаемые поля:
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения.
//  ПравоеЗначение - произвольный.
//  Представление - представление элемента компоновки данных.
//  Использование - булево - использование элемента.
//
Процедура УстановитьЭлементОтбора(ОбластьПоискаДобавления,
								знач ИмяПоля,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Представление = Неопределено,
								знач Использование = Неопределено) Экспорт
	
	ЧислоИзмененных = ИзменитьЭлементыОтбора(ОбластьПоискаДобавления, ИмяПоля, Представление,
							ПравоеЗначение, ВидСравнения, Использование);
	
	Если ЧислоИзмененных = 0 Тогда
		Если ВидСравнения = Неопределено Тогда
			ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		КонецЕсли;
		ДобавитьЭлементКомпоновки(ОбластьПоискаДобавления, ИмяПоля, ВидСравнения,
								ПравоеЗначение, Представление, Использование);
	КонецЕсли;
	
КонецПроцедуры

// Изменение элементов отбора
// Параметры:
//  ИмяПоля - строка - имя поля компоновки.
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения.
//  ПравоеЗначение - произвольный.
//  Представление - строка - представление элемента компоновки данных.
//
Функция ИзменитьЭлементыОтбора(ОбластьПоиска,
								знач ИмяПоля = Неопределено,
								знач Представление = Неопределено,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Использование = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если ИмяПоля <> Неопределено Тогда
			Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
		КонецЕсли;
		Если Представление <> Неопределено Тогда
			Элемент.Представление = Представление;
		КонецЕсли;
		Если Использование <> Неопределено Тогда
			Элемент.Использование = Использование;
		КонецЕсли;
		Если ВидСравнения <> Неопределено Тогда
			Элемент.ВидСравнения = ВидСравнения;
		КонецЕсли;
		Если ПравоеЗначение <> Неопределено Тогда
			Элемент.ПравоеЗначение = ПравоеЗначение;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивЭлементов.Количество();
	
КонецФункции

Процедура НайтиРекурсивно(КоллекцияЭлементов, МассивЭлементов, СпособПоиска, ЗначениеПоиска)
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			
			Если СпособПоиска = 1 Тогда
				Если ЭлементОтбора.ЛевоеЗначение = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			ИначеЕсли СпособПоиска = 2 Тогда
				Если ЭлементОтбора.Представление = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			КонецЕсли;
		Иначе
			
			НайтиРекурсивно(ЭлементОтбора.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
			
			Если СпособПоиска = 2 И ЭлементОтбора.Представление = ЗначениеПоиска Тогда
				МассивЭлементов.Добавить(ЭлементОтбора);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Добавление элемента компоновки в контейнер элементов компоновки.
// Параметры:
//  ОбластьДобавления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе.
//  ИмяПоля - строка - имя для поля компоновки данных.
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения.
//  ПравоеЗначение - произвольный.
//  Представление - представление элемента компоновки данных.
//  Использование - булево - использование элемента.
//
Функция ДобавитьЭлементКомпоновки(ОбластьДобавления,
									знач ИмяПоля,
									знач ВидСравнения,
									знач ПравоеЗначение = Неопределено,
									знач Представление  = Неопределено,
									знач Использование  = Неопределено) Экспорт
	
	Элемент = ОбластьДобавления.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	Элемент.ВидСравнения = ВидСравнения;
	
	Если ПравоеЗначение <> Неопределено Тогда
		Элемент.ПравоеЗначение = ПравоеЗначение;
	КонецЕсли;
	
	Если Представление <> Неопределено Тогда
		Элемент.Представление = Представление;
	КонецЕсли;
	
	Если Использование <> Неопределено Тогда
		Элемент.Использование = Использование;
	КонецЕсли;
	
	Возврат Элемент;
	
КонецФункции

// Заглушка для методов типа НачатьЗапускПриложения, с обязательным ОписаниеОповещения
Процедура ОбработчикОповещенияБезДействия(Результат, ДополнительныеПараметры) Экспорт
	
КонецПроцедуры


#Область РаботаСМножествами

Функция ПересечениеМножеств(Множество1, Множество2) Экспорт
	
	Результат = Новый Массив;
	
	Для Каждого Элемент Из Множество1 Цикл
		Индекс = Множество2.Найти(Элемент);
		Если Индекс <> Неопределено Тогда
			Результат.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти